# 进程
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位
## 进程的五态
---
创建 就绪 运行 阻塞 终止
+ 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度
+ 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态
## 进程同步
---
某些进程为完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协 调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后方被唤醒并继续执行。这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步，进程同步指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒

## 进程通信
---
进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息
1. 管道
2. 命名管道
3. 消息队列
4. 信号量
5. 信号
6. 共享内存
7. 套接字 （可用于远程通信，网络编程）
8. 全双工管道 (可用于远程通信，网络编程)
   
信号和信号量的区别：
+ 信号：是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常
+ 信号量：信号量是一个特殊的变量，它的本质是计数器，信号量里面记录了临界资源的数目，有多少数目，信号量的值就为多少，进程对其访问都是原子操作（pv操作，p：占用资源，v：释放资源）。它的作用就是，调协进程对共享资源的访问，让一个临界区同一时间只有一个进程在访问它

## 进程控制
### fork()
系统调用fork()用于创建一个新进程，称为子进程，它与进行fork()调用的进程(父进程)并发运行。创建新的子进程后，两个进程都将执行fork()系统调用之后的下一条指令。子进程使用相同的PC(程序计数器)，相同的CPU寄存器，相同的打开文件，这些文件在父进程中使用

它不接受任何参数并返回一个整数值
+ 负值：创建子进程失败
+ 零：返回到新创建的子进程
+ 正值：返回给父亲或调用者。该值包含新创建子进程的进程ID

#### fork()与vfork()的区别
+  fork()：子进程拷贝父进程的数据段，代码段 vfork()：子进程与父进程共享数据段
+ fork()父子进程的执行次序不确定,vfork()保证子进程先运行，在调用exec()或exit()之前与父进程数据是共享的,在它调用exec()或exit()之后父进程才可能被调度运行
+ vfork()保证子进程先运行，在她调用exec()或exit()之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁

### wait()
父进程执行了wait()函数后，如果子进程已经发生了状态变化，则wait()函数立即就会有返回结果；否则wait()函数会一直阻塞直至子进程状态发生变化

通常意义上，如果子进程已经发生了状态变化，但还未被父进程或其它系统回调执行wait，则把此时的子进程称为是可等待的(waitable)

子进程运行结束后，父进行执行wait()函数可以推动系统释放与子进程相关的资源；否则子进程将会被维持在僵尸进程的状态下一直存在

### exit()
结束当前继承/程序，在整个程序中，只要调用exit，就结束

return() 是当前函数返回，当然如果是在主函数main, 自然也就结束当前进程了，如果不是，那就是退回上一层调用。在多个进程时.如果有时要检测上进程是否正常退出的.就要用到上个进程的返回值

exit(1)表示进程正常退出. 返回 1

exit(0)表示进程非正常退出. 返回 0

### exec()
fork()函数通过系统调用创建一个与原来进程（父进程）几乎完全相同的进程（子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程不共享这些存储空间。linux将复制父进程的地址空间内容给子进程，因此，子进程由了独立的地址空间。），也就是这两个进程做完全相同的事

在fork后的子进程中使用exec函数族，可以装入和运行其它程序,exec函数族可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段
# 线程
线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位
| 线程独享资源 | 线程共享资源 | 
| ---- | ---- |
| 栈 | 堆 |
| 寄存器 | 全局变量 |
| 线程ID | 静态变量 |
| 错误返回码 | 文件等公共资源 |
| 信号屏蔽码 | 闹铃 |
| 线程优先级 | |

## 线程通信
---
1. 锁机制
2. 信号量机制
3. 信号机制

## 什么时候用多线程/多进程
---
使用多线程：IO密集型，读取网络套接字频繁

使用多进程：计算密集型，大量消耗CPU的数学与逻辑运算
# 协程
协程，是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源

协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行

优势：
+ 极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显
+ 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多