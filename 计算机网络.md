# http
## 请求报文
请求行+请求头+请求体

![image.png](http://ww1.sinaimg.cn/large/007y4ewTly1girftp9djej30bl04ht8v.jpg)

![image.png](http://ww1.sinaimg.cn/large/007y4ewTly1girfva7k3jj30n70cewou.jpg)

请求行：
+ 请求方法 GET/POST等等
+ 请求对应的URL地址
+ HTTP协议及版本
  
请求头：
+ 若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息

请求体：
+ 它将一个页面表单中的组件值通过param1=value1&param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&param2=value2”的方式传递请求参数

## 响应报文
响应行+响应头+响应体

![image.png](http://ww1.sinaimg.cn/large/007y4ewTly1girg5768cvj30ii09ignk.jpg)

响应行：
+ HTTP协议及版本
+ 状态码及状态描述
  - 1xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急...
  - 2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息
  - 3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理
  - 4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等
  - 5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等

响应头：
+ 与请求头类似，由多个属性组成

响应体：
+ 客户端真正需要的内容
  
### POST/GET区别
POST和GET是HTTP请求的两种方式，都可实现将数据从浏览器向服务器发送带参数的请求
#### GET
GET是获取的意思，顾名思义就是获取信息，是默认的HTTP请求方法

GET方法把参数通过key/value形式存放在URL里面，如果参数是英文数字原样显示，如果是中文或者其他字符加密（Base64）URL长度一般有限制所以GET方法的参数长度不能太长。由于参数显示再地址栏所以不安全，一般需要保密的请求不使用GET

#### POST
POST是邮件的意思，顾名思义就像一封信一样将参数放在信封里面传输。它用于修改服务器上的数据，一般这些数据是应该保密的，就像信件一样，信的内容只能收信的人看见。例入当用户输入账号和密码登录时账号和密码作为参数通过HTTP请求传输到服务器，这时候肯定不能用GET方法将账号密码直接显示再URL上，这时候就应该用POST方法保证数据的保密性

区别：
1. GET提交的数据放在URL中，POST则不会。这是最显而易见的差别。这点意味着GET更不安全（POST也不安全，因为HTTP是明文传输抓包就能获取数据内容，要想安全还得加密）
2. GET回退浏览器无害，POST会再次提交请求（GET方法回退后浏览器再缓存中拿结果，POST每次都会创建新资源）
3. GET提交的数据大小有限制（是因为浏览器对URL的长度有限制，GET本身没有限制），POST没有
4. GET可以被保存为书签，POST不可以
5. GET能被缓存，POST不能
6. GET只允许ASCII字符，POST没有限制
7. GET会保存再浏览器历史记录中，POST不会
## 各版本区别
| | |
| --- | --- |
|HTTP/0.9|只允许客户端发送一种GET请求，不支持请求头，只支持纯文本一种内容，服务器只能回应HTML格式的字符串，里边不能插入图片|
|HTTP/1.0|支持GET、POST、HEAD三种HTTP请求方法，任何格式的文件都可以发送，默认情况短连接|
|HTTP/1.1|引入了长链接，支持只发送header头信息不带任何body信息，增加了host处理|
|HTTP/2.0|2.0相比于1.x版本中引入了二进制格式，出错率低，支持多路复用，支持同一个链接并发处理多个请求，并且并发请求的数量要比以前高出很多的数量级，通过算法把header进行了压缩，还支持服务器推送|
## https
与http的区别：
1. https 协议需要到 ca 申请证书
2. http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议
3. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443
4. http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全
### 加密方式
Https采用对称加密和非对称加密结合的方式来进行通信

+ 对称加密：加密和解密都是同一个密匙
+ 非对称加密：密钥成对出现，分为公钥和私钥，公钥加密需要私钥解密，私钥加密需要公钥解密

步骤：
1. 浏览器使用Https的URL访问服务器，建立SSL链接
2. 服务器收到SSL链接，发送非对称加密的公钥A返回给浏览器
3. 浏览器生成随机数，作为对称加密的密钥B
4. 浏览器使用公钥A，对自己生成的密钥B进行加密，得到密钥C
5. 浏览器将密钥C，发送给服务器
6. 服务器用私钥D对接受的密钥C进行解密，得到对称加密钥B
7. 浏览器和服务器之间可以用密钥B作为对称加密密钥进行通信

这样浏览器和服务器就共享一个对称加密密钥B，重要的是不会被拦截到。只在传输密钥B的时候进行了一次非对称加密，之后就用对称加密进行传送数据
### HTTPS 安全又可靠， 为何不一直使用？
1. 与纯文本通信相比，加密通信会消耗更多的CPU 及内存资源，如果每次通信都加密， 会消耗相当多的资源， 平摊到一台计算机上时， 能够处理的请求数量必定也会随之减少。因此， 如果是非敏感信息则使用 HTTP 通信， 只有在包含个人信息等敏感数据时， 才利用 HTTPS 加密通信。特别是每当那些访问量较多的 Web 网站在进行加密处理时， 它们所承担着的负载不容小觑。 在进行加密处理时， 并非对所有内容都进行加密处理， 而是仅在那些需要信息隐藏时才会加密， 以节约资源
2. 节约购买证书的开销，要进行 HTTPS 通信， 证书是必不可少的。 而使用的证书必须向认证机构（CA） 购买。 那些购买证书并不合算的服务以及一些个人网站，可能只会选择采用 HTTP 的通信方式
# tcp/udp
## tcp首部
![image.png](http://ww1.sinaimg.cn/large/007y4ewTly1gj6g33ykxlj30dp08zjvd.jpg)

 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号

 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号

 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效

 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0 

 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

 ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号 
## 两者区别
||UDP|TCP|
|---|---|---|
|是否连接|无连接|面向连接|
|是否可靠|不可靠传输，不使用流量控制和拥塞控制|可靠传输，使用流量控制和拥塞控制|
|连接对象个数|支持一对一，一对多，多对一和多对多交互通信|只能是一对一通信|
|传输方式|面向报文|面向字节流|
|首部开销|首部开销小，仅8字节|首部最小20字节，最大60字节|
|适用场景|适用于实时应用（IP电话、视频会议、直播等）|适用于要求可靠传输的应用，例如文件传输|
## 三次握手
![image.png](http://ww1.sinaimg.cn/large/007y4ewTly1girgl7eaxmj30ei09d42p.jpg)

### 为什么不能用两次握手进行连接？
三次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁
### 为什么不用四次握手
四次握手的过程
1. A发送同步信号
2. B确认收到A的同步信号
3. B发送同步信号
4. A确认收到B的同步信号

显然 2 3 可以合并，提高连接的效率与步骤

### 一些关于丢包的补充
第一个包，即A发给B的SYN中途被丢，没有到达B
+ A会周期性超时重传，直到收到B的确认
第二个包，即B发给A的SYN+ACK中途被丢，没有到达A
+ B会周期性超时重传，直到收到A的确认
第三个包，即A发给B的ACK 中途被丢，没有到达B
+ 第三个包，即A发给B的ACK 中途被丢，没有到达B
  1. 假定此时双方都没有数据发送,B会周期性超时重传,直到收到A的确认,收到之后B的TCP连接也为 Established状态，双向可以发包
  2. 假定此时A有数据发送,B收到A的 Data + ACK,自然会切换为established 状态,并接受A的Data
  3. 假定B有数据发送,数据发送不了,会一直周期性超时重传SYN + ACK,直到收到A的确认才可以发送数据
## 四次挥手
![image.png](http://ww1.sinaimg.cn/large/007y4ewTly1girglkfp41j30fd0a60y2.jpg)

### 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接
## tcp靠什么保证可靠性
1. 检验和
+ TCP检验和的计算与UDP一样，在计算时要加上12byte的伪首部，检验范围包括TCP首部及数据部分，但是UDP的检验和字段为可选的，而TCP中是必须有的。计算方法为：在发送方将整个报文段分为多个16位的段，然后将所有段进行反码相加，将结果存放在检验和字段中，接收方用相同的方法进行计算，如最终结果为检验字段所有位是全1则正确（UDP中为0是正确），否则存在错误
2. 序列号
3. 确认应答机制（ACK）
4. 超时重传机制
+ 当报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传（通常是在发出报文段后设定一个闹钟，到点了还没有收到应答则进行重传）
5. 连接管理机制（三次握手四次挥手）
6. 流量控制
+ 在TCP报文段首部中有一个16位窗口长度，当接收端接收到发送方的数据后，在应答报文ACK中就将自身缓冲区的剩余大小，放入16窗口大小中。这个大小随数据传输情况而变，窗口越大，网络吞吐量越高，而一旦接收方发现自身的缓冲区快满了，就将窗口设置为更小的值通知发送方。如果缓冲区满，就将窗口置为0，发送方收到后就不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端
7. 拥塞控制
# 其他
## 输入一个网址后发生了什么
---
1. DNS解析
+ 先查找浏览器缓存
+ 上面没找到，则查找操作系统缓存
+ 上面没找到，则查找路由器缓存
+ 上面没找到，请求发送到ISP(Internet Service Provider，互联网服务提供商，就是网络运营商，中国电信中国移动等),在本地DNS服务器上查找
+ 上面没找到，到根域名服务器上搜索
2. 进行TCP连接
3. 浏览器发送http请求
+ 方式为get
4. 服务器处理请求
5. 浏览器解析渲染页面
6. 关闭TCP连接
## ping发生了什么
ping依托于ICMP协议
1. 主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表项中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B
2. 如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求数据包以主机A的IP地址和MAC地址作为发送者IP地址和发送者MAC地址，以主机B的IP地址和全0的MAC地址作为目标IP地址和目标MAC地址。由于ARP请求数据包以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理
3. 主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：首先把ARP请求数据包中的请求发起者（即主机A）的IP地址和MAC地址存入自己的ARP表项中。然后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址
4. 主机A收到响应数据包后，将主机B的MAC地址加入到自己的ARP表中，从而完成一次ARP解析过程

![image.png](http://ww1.sinaimg.cn/large/007y4ewTly1gisu5292bzj30p40c6jrv.jpg)

## 什么是DNS
Domain Network System域名系统（DNS）是因特网的电话簿。人类通过域名在线访问信息，如nytimes.com或espn.com。Web浏览器通过Internet协议（IP）地址进行交互。DNS将域名转换为IP地址，以便浏览器可以加载Internet资源